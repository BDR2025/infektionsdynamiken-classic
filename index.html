<!doctype html>
<html lang="de" data-mode="school" data-page="explore">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kompartiment-Simulator V2.42 — Classic</title>

<!-- =========================================================
  Infektionsdynamiken verstehen · Classic Edition
  Single-file build · Stand: 2025-07-01
  Lizenz: CC BY 4.0 · B. D. Rausch
  Hinweis: Diese „Classic“-Datei ist bewusst self-contained (inline)
========================================================= -->

<style>
/* === UID Style Bridge · School-Theme only =================== */
:root{
  /* Flächen, Typo, Ränder */
  --bg:#F7FAFC; --fg:#0B1520; --muted:#6B7785;
  --panel:#FFFFFF; --panel-2:#F1F5F9; --border:#D6DFEA;
  /* Brand + Focus */
  --brand:#2EC27E;
  --ring:#1AA385;
  --focus:0 0 0 3px color-mix(in srgb, var(--brand) 35%, transparent);
  /* Kompartimentfarben */
  --c-s:#22C55E; --c-i:#EF4444; --c-r:#3B82F6; --c-e:#EAB308; --c-d:#475569; --c-v:#9333EA;
  /* Bridges (Kompatibilität zu Classic) */
  --s:var(--c-s); --e:var(--c-e); --i:var(--c-i); --r:var(--c-r); --d:var(--c-d); --v:var(--c-v);
  --accent:var(--brand);
  /* Radii/Shadows */
  --radius-md:.75rem; --radius-lg:1rem; --shadow-1:0 2px 8px rgba(2,6,23,.06);
}

/* ===== Base ===== */
*{box-sizing:border-box}
html,body{height:100%}
@supports (scrollbar-gutter: stable) { html{ scrollbar-gutter: stable both-edges; } }
body{
  margin:0; overflow-y:scroll;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  color:var(--fg); background:var(--bg);
}
.wrap{max-width:1140px;margin:24px auto;padding:0 16px;display:grid;gap:16px}
h1{font-size:28px;margin:0 0 4px}
.subtitle{margin:2px 0 10px;color:var(--muted);font-size:14px}

/* ===== Cards/Buttons/Controls (angepasst an School) ===== */
.card{
  border:1px solid var(--border); border-radius:var(--radius-lg); padding:12px; background:var(--panel);
  box-shadow:var(--shadow-1);
}
.cardHeader{display:flex;align-items:center;justify-content:space-between;margin:2px 2px 8px;gap:12px}
.cardTitle{margin:0;font-size:18px;display:flex;flex-wrap:wrap;gap:8px;align-items:center}

.tools{display:flex;gap:8px;align-items:center;margin-left:auto}
.btn{
  appearance:none;background:var(--panel);border:1px solid var(--border);
  border-radius:10px;padding:8px 10px;font-weight:600;cursor:pointer;color:var(--fg)
}
.btn:hover{border-color:#cbd5e1}
.btn[disabled]{opacity:.5;cursor:not-allowed}

/* Toggle */
.toggle{display:inline-flex;border:1px solid var(--border);border-radius:10px;overflow:hidden;margin-left:4px;background:var(--panel)}
.toggle button{border:0;background:transparent;padding:8px 10px;font-weight:600;cursor:pointer;color:var(--fg)}
.toggle button.active{background:var(--accent);color:#fff}
.toggle button:not(.active):hover{background:#f8fafc}

/* Custom Dropdown */
.modelPicker{position:relative;display:inline-block}
.modelBtn{
  display:inline-flex;align-items:center;gap:8px;border:1px solid var(--border);border-radius:10px;
  background:var(--panel);padding:8px 10px;cursor:pointer;font-weight:600;color:var(--fg)
}
.modelBtn:after{content:"▾";font-size:12px;color:#334155}
.modelList{
  position:absolute;z-index:20;top:100%;left:0;min-width:340px;background:var(--panel);
  border:1px solid var(--border);border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.08);padding:6px;margin-top:6px;display:none
}
.modelItem{display:flex;align-items:center;gap:10px;padding:8px 10px;border-radius:8px;cursor:pointer}
.modelItem:hover,.modelItem[aria-selected="true"]{background:#f8fafc}
.dots{display:inline-flex;gap:6px;min-width:56px;justify-content:flex-start}
.dot{display:inline-block;width:10px;height:10px;border-radius:999px}
.dot.s{background:var(--s)} .dot.e{background:var(--e)} .dot.i{background:var(--i)} .dot.r{background:var(--r)} .dot.d{background:var(--d)} .dot.v{background:var(--v)}
.vh{position:absolute !important;width:1px;height:1px;margin:-1px;border:0;padding:0;white-space:nowrap;clip-path:inset(100%);clip:rect(0 0 0 0);overflow:hidden}

/* Chart area */
.chartPh{
  width:100%; height:420px; border:1px dashed var(--border); border-radius:8px;
  display:flex; align-items:center; justify-content:center; color:var(--muted); font-size:14px;
  position:relative; overflow:hidden; background:var(--panel);
  box-shadow: 0 1px 2px rgba(2,6,23,.04), 0 8px 16px rgba(2,6,23,.06);
}
#chartCanvas{width:100%;height:100%;display:block}

/* Section Blocks */
.section{border:1px solid var(--border);border-radius:16px;padding:16px;background:var(--panel)}
.section h3{margin:0 0 10px}

/* Controls grid */
.msGrid{display:grid;gap:16px;grid-template-columns:1fr}
@media (min-width: 960px){ .msGrid{grid-template-columns:1fr 1fr} }

.controlsPh,.kpisPh,.noteBox,.explainBox,.infoSection{
  border:1px dashed var(--border); border-radius:12px; padding:12px; color:var(--muted); background:var(--panel);
  box-shadow: 0 1px 2px rgba(2,6,23,.04), 0 8px 16px rgba(2,6,23,.06);
}
.controlsPh{min-height:180px}
.kpisPh{min-height:120px}

#controls .ctrlRow{display:grid;grid-template-columns:170px 1fr 95px;gap:8px;align-items:center;margin-bottom:8px}
#controls label{font-size:13px;color:var(--muted)}
#controls input[type="range"]{width:100%}
#controls input[type="number"]{width:95px;padding:6px;border:1px solid var(--border);border-radius:8px;color:var(--fg);background:var(--panel)}
#controls .hint{font-size:12px;color:#64748b;margin-top:8px}

/* KPIs */
#kpis .row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:6px}
#kpis b{color:var(--fg)}
.mono{font-variant-numeric:tabular-nums}

/* Info-Layout (links 2/3, rechts 1/3) */
.infoCols{display:grid;gap:12px;grid-template-columns:1fr}
@media (min-width: 960px){ .infoCols{ grid-template-columns: 2fr 1fr; } }
.infoLeft, .infoRight{ display:grid; gap:12px }
.infoSection h4{margin:0 0 6px;font-size:15px}
.infoSection p{margin:0;color:#334155;font-size:14px;line-height:1.55}
#info-desc,#info-assumptions,#info-math,#info-limits{white-space:pre-line}
.wiki-link{display:inline-block;margin-top:8px;font-size:13px;color:#2563eb;text-decoration:underline}
.wiki-right{ text-align:right }

/* Classic-Badge/Banner */
.classicBadge{
  display:inline-block; margin-left:8px; padding:3px 8px; border-radius:999px;
  background: color-mix(in srgb, var(--brand) 12%, var(--panel));
  border:1px solid var(--border); color:var(--brand); font-weight:700; font-size:12px; letter-spacing:.02em; text-transform:uppercase;
}
.classicBanner{
  border:1px solid var(--border); background:var(--panel-2); color:var(--fg);
  border-radius:12px; padding:10px 12px; font-size:14px; display:flex; align-items:center; gap:10px;
}
.classicBanner .cb-dot{ width:8px; height:8px; border-radius:999px; background:var(--brand); }
.classicBanner a{ color:var(--brand); font-weight:700; text-decoration:underline; }

/* Footer & Impressum */
.footerNote{
  display:block; width:100%; box-sizing:border-box; border-top:1px solid var(--border); border-bottom:1px solid var(--border);
  padding:10px 16px; margin:0; text-align:center; color:#475569; background:var(--panel); font-size:12px; line-height:1.5; position:relative; z-index:1;
}
.impressum{
  display:block; max-width:1140px; margin:12px auto 24px; padding:8px 16px 0;
  color:#475569; font-size:12px; line-height:1.5; clear: both; position:relative; z-index:1;
}
.impressum a{color:#475569}

/* ===== Print ===== */
.printOnly{display:none}
.screenOnly{display:initial}
header.screenOnly,footer.footerNote.screenOnly,section.impressum.screenOnly{display:block}
.modelPicker.screenOnly{display:inline-block}
@media print{
  @page{ size: A4; margin: 18mm; }
  body{ background:#fff }
  .wrap{ max-width: none; margin:0; padding:0; gap:12px }
  .screenOnly{ display:none !important }
  .printOnly{ display:block }
  .chartPh{ height:95mm; border:1px solid var(--border); box-shadow:none !important }
  .section{ border-color:var(--border) }
  .infoSection, .kpisPh, .controlsPh, .noteBox, .explainBox{ box-shadow: none !important }
  .printTable{ width:100%; border-collapse:collapse; font-size:12px; }
  .printTable th, .printTable td{ border:1px solid var(--border); padding:6px 8px; vertical-align:top }
  .printTable th{ background:#f8fafc; text-align:left; width:42% }
  .infoSection{ break-inside: avoid; page-break-inside: avoid; }
  a[href^="http"]::after{ content:" (" attr(href) ")"; font-weight:400 }
  #printHeader .classicTag{ font-weight:700; color:#7c2d12; }
}

/* Print header styles */
#printHeader h1{ font-size:28pt; line-height:1.2; margin:0 0 8px }
#printHeader .sub1{ font-size:13pt; line-height:1.4; margin:0 0 6px; color:#1f2937; font-weight:600 }
#printHeader .sub2{ font-size:13pt; line-height:1.4; margin:0 0 12px; color:#1f2937 }
#printHeader .authors{ font-size:12pt; color:#111827; margin:0 0 10px }
#printHeader .pub{ font-size:10.5pt; color:#6b7280; margin:0 0 4px }
#printHeader .version{ font-size:10.5pt; color:#111827; margin:6px 0 0 }
#printHeader a{ color:#2563eb; text-decoration:underline }
</style>

<!-- MathJax -->
<script>
window.MathJax = {
  tex: {inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$','$$'], ['\\[','\\]']]},
  svg: {fontCache: 'global'}
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
</head>
<body>
<div class="wrap">

  <!-- Screen Header -->
  <header class="screenOnly">
    <h1>Infektionsdynamiken verstehen <span class="classicBadge" title="Historische, gepflegte Version">Classic</span></h1>
    <div class="subtitle">SIR • SEIR • SIS • SIRD • SIRV — Fünf interaktive Modelle für den Öffentlichen Gesundheitsdienst</div>
  </header>

  <!-- Classic-Banner -->
  <section class="classicBanner screenOnly" role="note" aria-label="Classic Hinweis">
    <span class="cb-dot" aria-hidden="true"></span>
    <div>
      <b>Classic Edition.</b> Diese frühe Simulation war Innovationsgeber für das aktuelle Projekt "Infektionsdynamiken verstehen" und die UID-Explore-Engine.
      Aus Gründen der Nachvollziehbarkeit bleibt sie dauerhaft als „Classic“ erhalten (funktional stabil, behutsame Pflege).
      <a href="https://infektionsdynamiken.de" rel="noopener">Zur aktuellen Version</a>
    </div>
  </section>

  <!-- Print Header -->
  <section id="printHeader" class="printOnly">
    <h1>Infektionsdynamiken verstehen</h1>
    <p class="sub1">Fünf interaktive Modelle als praxisnahes Werkzeug für</p>
    <p class="sub2"><b>Schulung</b> und <b>Szenarioplanung</b> im Öffentlichen Gesundheitsdienst</p>
    <p class="authors">Boris Dominic Rausch</p>
    <p class="pub">https://bdr2025.github.io/Infektionsdynamiken-verstehen/: <a id="printDoi" href="https://bdr2025.github.io/Infektionsdynamiken-verstehen/">https://bdr2025.github.io/Infektionsdynamiken-verstehen/</a></p>
    <p class="version"><span class="classicTag">Classic Edition</span> · Simulator Version <span id="printVersion">2.42</span> · <span id="printTs"></span></p>
  </section>

  <!-- Card mit Chart -->
  <section class="card">
    <div class="cardHeader">
      <h3 class="cardTitle">
        <span id="titleText">SIR (Susceptible, Infected, Recovered)</span>
        <span class="modelPicker screenOnly" id="modelPicker">
          <button class="modelBtn" id="modelBtn" aria-haspopup="listbox" aria-expanded="false" aria-controls="modelList">
            Modell wählen
          </button>
          <div class="modelList" id="modelList" role="listbox" aria-label="Modell auswählen">
            <div class="modelItem" role="option" data-id="SIR" aria-selected="true">
              <span class="dots"><span class="dot s"></span><span class="dot i"></span><span class="dot r"></span></span>
              <span>SIR</span>
            </div>
            <div class="modelItem" role="option" data-id="SEIR">
              <span class="dots"><span class="dot s"></span><span class="dot e"></span><span class="dot i"></span><span class="dot r"></span></span>
              <span>SEIR</span>
            </div>
            <div class="modelItem" role="option" data-id="SIS">
              <span class="dots"><span class="dot s"></span><span class="dot i"></span></span>
              <span>SIS</span>
            </div>
            <div class="modelItem" role="option" data-id="SIRD">
              <span class="dots"><span class="dot s"></span><span class="dot i"></span><span class="dot r"></span><span class="dot d"></span></span>
              <span>SIRD</span>
            </div>
            <div class="modelItem" role="option" data-id="SIRV">
              <span class="dots"><span class="dot s"></span><span class="dot i"></span><span class="dot r"></span><span class="dot v"></span></span>
              <span>SIRV</span>
            </div>
          </div>
          <select class="vh" id="modelSelectNative" aria-label="Modell auswählen">
            <option value="SIR" selected>SIR</option>
            <option value="SEIR">SEIR</option>
            <option value="SIS">SIS</option>
            <option value="SIRD">SIRD</option>
            <option value="SIRV">SIRV</option>
          </select>
        </span>
      </h3>

      <div class="tools screenOnly">
        <button class="btn" id="btnReset" type="button">Zurücksetzen</button>
        <button class="btn" id="btnPNG"   type="button">PNG</button>
        <button class="btn" id="btnPDF"   type="button">PDF</button>
        <div class="toggle" role="tablist" aria-label="Ansicht wählen">
          <button id="toggleControl" class="active" role="tab" aria-selected="true" aria-controls="panelControl">Steuerung</button>
          <button id="toggleInfo" role="tab" aria-selected="false" aria-controls="panelInfo">Info</button>
        </div>
      </div>
    </div>

    <div class="chartPh">
      <canvas id="chartCanvas" aria-label="Diagramm der Kompartimente"></canvas>
    </div>
  </section>

  <!-- Steuerung -->
  <section class="section screenOnly" id="panelControl">
    <h3>Modellsteuerung</h3>
    <div class="msGrid">
      <div>
        <div class="controlsPh" id="controls"></div>
      </div>
      <div>
        <div class="kpiGroup">
          <div class="kpisPh" id="kpis">
            <div class="row"><b>R₀:</b> <span id="kpiR0" class="mono">–</span> <span id="kpiHerd" class="mono" title="Herdenschwelle"> (Schwelle: –)</span></div>
            <div class="row" id="kpiPeakRow"><b>Peak I:</b> <span id="kpiPeakI" class="mono">–</span> am Tag <span id="kpiPeakDay" class="mono">–</span></div>
            <div class="row"><b>Endstände:</b> <span id="kpiEnd" class="mono">–</span></div>
          </div>
          <div class="noteBox">Hinweis: KPIs aktualisieren sich automatisch bei jeder Änderung.</div>
          <div class="explainBox">Erklärung: $\\gamma = 1/D$, $R_0 = \\beta/\\gamma (= \\beta\\cdot D)$, Herdenschwelle $\\approx 1 - 1/R_0$ (falls $R_0>1$).</div>
        </div>
      </div>
    </div>
  </section>

  <!-- Print-only Parameter & KPIs -->
  <section id="printParams" class="printOnly section">
    <h3>Parameter (Snapshot)</h3>
    <table class="printTable" id="paramsTable"></table>
  </section>
  <section id="printKpis" class="printOnly section">
    <h3>Kennzahlen</h3>
    <table class="printTable" id="kpisTable"></table>
  </section>

  <!-- Modell-Info -->
  <section id="panelInfo" class="section" style="display:none">
    <h3>Modell-Informationen</h3>
    <div class="infoCols">
      <div class="infoLeft">
        <div class="infoSection"><h4>Beschreibung</h4><p id="info-desc">Beschreibung Modell SIR</p></div>
        <div class="infoSection"><h4>Annahmen</h4><p id="info-assumptions">Annahmen Modell SIR</p></div>
        <div class="infoSection"><h4>Limitationen</h4><p id="info-limits">Limitationen Modell SIR</p></div>
      </div>
      <div class="infoRight">
        <div class="infoSection"><h4>Berechnung</h4><p id="info-math">Berechnung Modell SIR</p></div>
        <div class="infoSection wiki-right"><h4>Weiterführend</h4><a id="wiki-link" href="#" target="_blank" class="wiki-link" rel="noopener">Wikipedia</a></div>
      </div>
    </div>
  </section>
</div>

<footer class="footerNote screenOnly">© 2025 — Infektionsdynamiken verstehen: Fünf interaktive Modelle zur Schulung im Öffentlichen Gesundheitsdienst.</footer>

<script>
/* ====== MODEL_INFO ====== */
const MODEL_INFO = {
  SIR: {
    desc: "Das SIR-Modell ist ein einfaches mathematisches Modell, das die Ausbreitung einer Infektionskrankheit beschreibt.\n\nEs unterteilt die Bevölkerung in drei Gruppen:\n- S (Susceptible / Anfällig) – noch nicht infiziert, aber empfänglich\n- I (Infected / Infiziert) – aktuell krank und ansteckend\n- R (Recovered / Genesen) – erholt und nicht mehr ansteckend\n\nDas Modell zeigt, wie Personen im Zeitverlauf von S zu I und schließlich zu R wechseln. Ausschlaggebend sind dabei die Übertragungsrate und die Dauer der Ansteckungsfähigkeit. Damit lässt sich abschätzen, ob eine Krankheit eine Epidemie auslöst oder abklingt, und wie Maßnahmen wie Abstand, Hygiene oder Impfungen den Verlauf beeinflussen.",
    wiki: "https://de.wikipedia.org/wiki/SIR-Modell",
    assumptions: "Zentrale Annahmen (vereinfachend):\n- Zu Beginn ist jede Person empfänglich (keine Vorerkrankungen/Immunität).\n- Gleichmäßige Durchmischung: gleiche Kontaktwahrscheinlichkeit für alle.\n- Nach Infektion sofort infektiös.\n- Einheitliche Krankheitsdauer für alle.\n- Nach Genesung dauerhaft immun (I → R, keine Reinfektion).\n- Bevölkerung besteht nur aus S, I, R (Geburten/Todesfälle außerhalb der Krankheit fehlen).",
    math:
      "Gleichungen (SIR):\n" +
      "$$\\frac{dS}{dt} = -\\beta \\frac{S I}{N}$$\n" +
      "$$\\frac{dI}{dt} = \\beta \\frac{S I}{N} - \\gamma I$$\n" +
      "$$\\frac{dR}{dt} = \\gamma I$$\n\n" +
      "Parameter:\n" +
      "$$\\begin{aligned}\n" +
      "  \\beta &= \\text{Übertragungsrate}\\\\\n" +
      "  \\gamma &= \\frac{1}{\\text{Dauer der Infektiosität}}\\\\\n" +
      "  N &= \\text{Gesamtbevölkerung}\\\\\n" +
      "  R_0 &= \\frac{\\beta}{\\gamma}\n" +
      "\\end{aligned}$$",
    limits: "Wichtige Limitationen:\n- (Teil-)Immunität zu Beginn wird nicht berücksichtigt.\n- Reale Kontaktstrukturen sind nicht homogen (Haushalte, Schulen, Arbeitsplätze).\n- Infektiösität variiert zwischen Personen und über die Zeit.\n- Reinfektionen sind bei manchen Krankheiten möglich.\n- Krankheits-/Infektionsdauern streuen; Infektiosität setzt oft verzögert ein.\n- β ist im Grundmodell konstant, reale Verhaltensänderungen/interventionen machen β zeitabhängig."
  },
  SEIR: {
    desc: "Das SEIR-Modell erweitert das SIR-Modell um eine zusätzliche Gruppe E (Exposed / Exponiert).\n\nDie vier Gruppen sind:\n- S (Susceptible / Anfällig) – noch nicht infiziert, aber empfänglich\n- E (Exposed / Exponiert) – infiziert, aber noch nicht infektiös (Inkubationszeit)\n- I (Infected / Infiziert) – infektiös\n- R (Recovered / Genesen) – erholt und nicht mehr ansteckend\n\nDieses Modell bildet Krankheiten realistischer ab, bei denen es zwischen Ansteckung und Ansteckungsfähigkeit eine Verzögerung gibt.",
    wiki: "https://de.wikipedia.org/wiki/SEIR-Modell",
    assumptions: "Zentrale Annahmen:\n- Nach Ansteckung folgt ein nicht-infektiöses Stadium (S → E), erst danach I.\n- Einheitliche Dauer der Inkubations- (E) und Infektionsphase (I).\n- Homogene Durchmischung; keine Reinfektion (wie bei SIR).\n- β (Kontakt/Übertragbarkeit) ist konstant.",
    math:
      "Gleichungen (SEIR):\n" +
      "$$\\frac{dS}{dt} = -\\beta \\frac{S I}{N}$$\n" +
      "$$\\frac{dE}{dt} = \\beta \\frac{S I}{N} - \\sigma E$$\n" +
      "$$\\frac{dI}{dt} = \\sigma E - \\gamma I$$\n" +
      "$$\\frac{dR}{dt} = \\gamma I$$\n\n" +
      "Parameter:\n" +
      "$$\\begin{aligned}\n" +
      "  \\beta &= \\text{Übertragungsrate}\\\\\n" +
      "  \\sigma &= \\frac{1}{\\text{Inkubationszeit}}\\\\\n" +
      "  \\gamma &= \\text{Genesungsrate}\\\\\n" +
      "  N &= \\text{Gesamtbevölkerung}\n" +
      "\\end{aligned}$$",
    limits: "Limitationen:\n- Inkubationszeit wird als fix/identisch modelliert; real variiert sie.\n- Prä-/asymptomatische Transmission kann höher oder niedriger sein als angenommen.\n- Gleiches Kontakt-/Verhaltensproblem wie bei SIR (fehlende Netzwerke, zeitabhängiges β)."
  },
  SIS: {
    desc: "Das SIS-Modell beschreibt Krankheiten, bei denen Genesung keine dauerhafte Immunität verleiht.\n\nAblauf:\n- S (Susceptible / Anfällig)\n- I (Infected / Infiziert)\n\nNach der Genesung kehren Personen in die Gruppe S zurück (I → S) und können sich erneut anstecken.\n\nBeispiele: einige Erkältungsviren, Gonorrhö.",
    wiki: "https://de.wikipedia.org/wiki/SIS-Modell",
    assumptions: "Zentrale Annahmen:\n- Keine schützende Immunität: Genesene werden wieder empfänglich (I → S).\n- Homogene Durchmischung; einheitliche Krankheitsdauer.\n- β ist konstant.",
    math:
      "Gleichungen (SIS):\n" +
      "$$\\frac{dS}{dt} = -\\beta \\frac{S I}{N} + \\gamma I$$\n" +
      "$$\\frac{dI}{dt} = \\beta \\frac{S I}{N} - \\gamma I$$\n\n" +
      "Parameter:\n" +
      "$$\\begin{aligned}\n" +
      "  \\beta &= \\text{Übertragungsrate}\\\\\n" +
      "  \\gamma &= \\text{Genesungsrate (Rückkehr zu S)}\\\\\n" +
      "  N &= \\text{Gesamtbevölkerung}\n" +
      "\\end{aligned}$$",
    limits: "Limitationen:\n- Temporäre oder partielle Immunität wird nicht abgebildet.\n- Heterogene Kontakte, Superspreading, Alters-/Risikostrukturen fehlen.\n- Interventionen/Verhaltensänderungen, die β verändern, fehlen."
  },
  SIRD: {
    desc: "Das SIRD-Modell erweitert das SIR-Modell um die Gruppe D (Deceased / Verstorben).\n\nDie Gruppen sind:\n- S (Susceptible / Anfällig)\n- I (Infected / Infiziert)\n- R (Recovered / Genesen)\n- D (Deceased / Verstorben)\n\nEs wird genutzt, wenn Sterblichkeit einen wesentlichen Einfluss auf die Dynamik hat.",
    wiki: "https://de.wikipedia.org/wiki/SIR-Modell#SIRD",
    assumptions: "Zentrale Annahmen:\n- Abgang aus I über zwei Wege: Genesung (I → R) oder Tod (I → D).\n- Sterblichkeitsrate μ ist konstant (zeitlich/personenunabhängig).\n- Homogene Durchmischung; keine Reinfektion.",
    math:
      "Gleichungen (SIRD):\n" +
      "$$\\frac{dS}{dt} = -\\beta \\frac{S I}{N}$$\n" +
      "$$\\frac{dI}{dt} = \\beta \\frac{S I}{N} - \\gamma I - \\mu I$$\n" +
      "$$\\frac{dR}{dt} = \\gamma I$$\n" +
      "$$\\frac{dD}{dt} = \\mu I$$\n\n" +
      "Parameter:\n" +
      "$$\\begin{aligned}\n" +
      "  \\beta &= \\text{Übertragungsrate}\\\\\n" +
      "  \\gamma &= \\text{Genesungsrate}\\\\\n" +
      "  \\mu &= \\text{Sterberate}\\\\\n" +
      "  N &= \\text{Gesamtbevölkerung}\n" +
      "\\end{aligned}$$",
    limits: "Limitationen:\n- Alters-/Risikounterschiede in der Letalität fehlen.\n- Behandlungsqualität/Überlastung (zeitabhängige Letalität) fehlen.\n- Kontaktheterogenität/zeitabhängiges β fehlen."
  },
  SIRV: {
    desc: "Das SIRV-Modell ergänzt das SIR-Modell um V (Vaccinated / Geimpft).",
    wiki: "https://de.wikipedia.org/wiki/SIR-Modell#SIRV",
    assumptions: "Geimpfte verbleiben in V; konstante Impfrate ν.",
    math:
      "$$\\frac{dS}{dt} = -\\beta \\frac{S I}{N} - \\nu S$$\n" +
      "$$\\frac{dI}{dt} = \\beta \\frac{S I}{N} - \\gamma I$$\n" +
      "$$\\frac{dR}{dt} = \\gamma I$$\n" +
      "$$\\frac{dV}{dt} = \\nu S$$",
    limits: "Kein Waning/Breakthrough; keine Priorisierung."
  }
};

/* ====== Toggle Panels ====== */
const toggleControl = document.getElementById('toggleControl');
const toggleInfo    = document.getElementById('toggleInfo');
const panelControl  = document.getElementById('panelControl');
const panelInfo     = document.getElementById('panelInfo');
function showPanel(which){
  if(which==='control'){
    panelControl.style.display='block'; panelInfo.style.display='none';
    toggleControl.classList.add('active'); toggleControl.setAttribute('aria-selected','true');
    toggleInfo.classList.remove('active'); toggleInfo.setAttribute('aria-selected','false');
  }else{
    panelControl.style.display='none'; panelInfo.style.display='block';
    toggleInfo.classList.add('active'); toggleInfo.setAttribute('aria-selected','true');
    toggleControl.classList.remove('active'); toggleControl.setAttribute('aria-selected','false');
    renderModelInfo(currentModel);
  }
  scheduleRedraw();
}
if(toggleControl && toggleInfo){
  toggleControl.addEventListener('click', ()=>showPanel('control'));
  toggleInfo.addEventListener('click',    ()=>showPanel('info'));
}

/* ====== Custom Dropdown ====== */
const modelBtn   = document.getElementById('modelBtn');
const modelList  = document.getElementById('modelList');
const modelItems = modelList ? Array.from(modelList.querySelectorAll('.modelItem')) : [];
const nativeSel  = document.getElementById('modelSelectNative');
const titleText  = document.getElementById('titleText');
const TITLE_MAP  = {
  SIR:  'SIR (Susceptible, Infected, Recovered)',
  SEIR: 'SEIR (Susceptible, Exposed, Infected, Recovered)',
  SIS:  'SIS (Susceptible, Infected, Susceptible)',
  SIRD: 'SIRD (Susceptible, Infected, Recovered, Deceased)',
  SIRV: 'SIRV (Susceptible, Infected, Recovered, Vaccinated)'
};
let currentModel = 'SIR';
function openList(){ if(modelList){ modelList.style.display='block'; modelBtn.setAttribute('aria-expanded','true'); modelItems[0]?.focus(); } }
function closeList(){ if(modelList){ modelList.style.display='none';  modelBtn.setAttribute('aria-expanded','false'); } }
function selectModel(id){
  currentModel = id;
  modelItems.forEach(el=>el.setAttribute('aria-selected', el.dataset.id===id ? 'true' : 'false'));
  if(titleText) titleText.textContent = TITLE_MAP[id] || id;
  if(nativeSel) nativeSel.value = id;
  renderControls(id);
  renderModelInfo(id);
  runAndDraw();
  closeList();
}
if(modelBtn){
  modelBtn.addEventListener('click', (e)=>{
    e.stopPropagation();
    const isOpen = modelList.style.display==='block';
    if(isOpen) closeList(); else openList();
  });
}
modelItems.forEach((el, idx)=>{
  el.addEventListener('click', (e)=>{ e.stopPropagation(); selectModel(el.dataset.id); });
  el.addEventListener('keydown', (e)=>{
    const key=e.key;
    if(key==='Enter' || key===' '){ e.preventDefault(); selectModel(el.dataset.id); }
    if(key==='Escape'){ e.preventDefault(); closeList(); modelBtn.focus(); }
    if(key==='ArrowDown'){ e.preventDefault(); (modelItems[idx+1]||modelItems[0]).focus(); }
    if(key==='ArrowUp'){ e.preventDefault(); (modelItems[idx-1]||modelItems[modelItems.length-1]).focus(); }
  });
  el.tabIndex=-1;
});
document.addEventListener('click', (e)=>{ if(modelList && !modelList.contains(e.target) && !modelBtn.contains(e.target)) closeList(); });
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeList(); });

/* ====== Info Rendering ====== */
const infoDesc = document.getElementById('info-desc');
const infoAss  = document.getElementById('info-assumptions');
const infoMath = document.getElementById('info-math');
const infoLim  = document.getElementById('info-limits');
const wikiLink = document.getElementById('wiki-link');
function nl2br(s){ return (s||'').replace(/\\n/g,'<br>'); }
async function typeset(el){
  if(window.MathJax && MathJax.typesetPromise){ try{ await MathJax.typesetPromise([el]); }catch(e){} }
}
function renderModelInfo(model){
  const d = MODEL_INFO[model] || {};
  if(infoDesc) infoDesc.innerHTML = nl2br(d.desc || '');
  if(infoAss)  infoAss.innerHTML  = nl2br(d.assumptions || '');
  if(infoMath) infoMath.innerHTML = nl2br(d.math || '');
  if(infoLim)  infoLim.innerHTML  = nl2br(d.limits || '');
  if(d.wiki && wikiLink){ wikiLink.href = d.wiki; wikiLink.style.display='inline-block'; } else if(wikiLink){ wikiLink.removeAttribute('href'); wikiLink.style.display='none'; }
  typeset(document.getElementById('panelInfo'));
}

/* ====== Controls, Simulation, Chart, KPIs, PNG, PDF ====== */
const DEFAULTS = {
  SIR:  { N:1_000_000, I0:10,  beta:0.30, inf_days:5,   days:160 },
  SEIR: { N:1_000_000, E0:20, I0:10, beta:0.30, inc_days:3, inf_days:5, days:180 },
  SIS:  { N:1_000_000, I0:10,  beta:0.30, inf_days:5,   days:160 },
  SIRD: { N:1_000_000, I0:10,  beta:0.30, inf_days:5, mu:0.002, days:160 },
  SIRV: { N:1_000_000, I0:10,  beta:0.30, inf_days:5, nu:0.005, V0:0, days:200 }
};
const CONTROLS = {
  SIR: [
    {key:'N', label:'Bevölkerung N', type:'int',  min:1000, max:10_000_000, step:1000},
    {key:'I0',label:'Infiziert zu Beginn I₀', type:'int', min:1, max:100_000, step:1},
    {key:'beta', label:'Übertragungsrate β (/Tag)', type:'float', min:0.02, max:1.5, step:0.01},
    {key:'inf_days', label:'Infekt.-Dauer D (Tage)', type:'float', min:1, max:21, step:0.1},
    {key:'days', label:'Simulationsdauer (Tage)', type:'int', min:30, max:365, step:1}
  ],
  SEIR: [
    {key:'N', label:'Bevölkerung N', type:'int',  min:1000, max:10_000_000, step:1000},
    {key:'E0',label:'Exponiert zu Beginn E₀', type:'int', min:0, max:100_000, step:1},
    {key:'I0',label:'Infiziert zu Beginn I₀', type:'int', min:1, max:100_000, step:1},
    {key:'beta', label:'Übertragungsrate β (/Tag)', type:'float', min:0.02, max:1.5, step:0.01},
    {key:'inc_days', label:'Inkubationszeit L (Tage)', type:'float', min:0.5, max:14, step:0.1},
    {key:'inf_days', label:'Infekt.-Dauer D (Tage)', type:'float', min:1, max:21, step:0.1},
    {key:'days', label:'Simulationsdauer (Tage)', type:'int', min:30, max:365, step:1}
  ],
  SIS: [
    {key:'N', label:'Bevölkerung N', type:'int',  min:1000, max:10_000_000, step:1000},
    {key:'I0',label:'Infiziert zu Beginn I₀', type:'int', min:1, max:100_000, step:1},
    {key:'beta', label:'Übertragungsrate β (/Tag)', type:'float', min:0.02, max:1.5, step:0.01},
    {key:'inf_days', label:'Krankheitsdauer D (Tage)', type:'float', min:1, max:21, step:0.1},
    {key:'days', label:'Simulationsdauer (Tage)', type:'int', min:30, max:365, step:1}
  ],
  SIRD: [
    {key:'N', label:'Bevölkerung N', type:'int',  min:1000, max:10_000_000, step:1000},
    {key:'I0',label:'Infiziert zu Beginn I₀', type:'int', min:1, max:100_000, step:1},
    {key:'beta', label:'Übertragungsrate β (/Tag)', type:'float', min:0.02, max:1.5, step:0.01},
    {key:'inf_days', label:'Infekt.-Dauer D (Tage)', type:'float', min:1, max:21, step:0.1},
    {key:'mu', label:'Sterberate μ (/Tag)', type:'float', min:0, max:0.05, step:0.0005},
    {key:'days', label:'Simulationsdauer (Tage)', type:'int', min:30, max:365, step:1}
  ],
  SIRV: [
    {key:'N', label:'Bevölkerung N', type:'int',  min:1000, max:10_000_000, step:1000},
    {key:'I0',label:'Infiziert zu Beginn I₀', type:'int', min:1, max:100_000, step:1},
    {key:'beta', label:'Übertragungsrate β (/Tag)', type:'float', min:0.02, max:1.5, step:0.01},
    {key:'inf_days', label:'Infekt.-Dauer D (Tage)', type:'float', min:1, max:21, step:0.1},
    {key:'nu', label:'Impfrate ν (/Tag)', type:'float', min:0, max:0.2, step:0.001},
    {key:'V0', label:'Geimpft zu Beginn V₀', type:'int', min:0, max:5_000_000, step:1},
    {key:'days', label:'Simulationsdauer (Tage)', type:'int', min:30, max:365, step:1}
  ]
};
const controlsEl = document.getElementById('controls');
function numfmt(x){ return x.toLocaleString('de-DE'); }
function renderControls(model){
  if(!controlsEl) return;
  const defs = CONTROLS[model];
  const defaults = DEFAULTS[model];
  let html = '';
  defs.forEach(def=>{
    const v = defaults[def.key];
    const inputId = `ctrl-${def.key}`;
    const rangeId = `${inputId}-range`;
    html += `
      <div class="ctrlRow">
        <label for="${rangeId}">${def.label}</label>
        <input type="range" id="${rangeId}" min="${def.min}" max="${def.max}" step="${def.step}" value="${v}">
        <input type="number" id="${inputId}"   min="${def.min}" max="${def.max}" step="${def.step}" value="${v}">
      </div>
    `;
  });
  html += `<div class="hint">Tipp: Zahlenfeld fokussieren und mit ↑/↓ in feinen Schritten anpassen.</div>`;
  controlsEl.innerHTML = html;

  defs.forEach(def=>{
    const num   = document.getElementById(`ctrl-${def.key}`);
    const range = document.getElementById(`ctrl-${def.key}-range`);
    const sync = (from, to)=>{ to.value = from.value; runAndDraw(); };
    range.addEventListener('input', ()=>sync(range, num));
    num.addEventListener('input',   ()=>{
      let val = parseFloat(num.value);
      if(isNaN(val)) return;
      val = Math.max(parseFloat(num.min), Math.min(parseFloat(num.max), val));
      num.value = val;
      sync(num, range);
    });
  });
}
function readParams(){
  const defs = CONTROLS[currentModel];
  const p = {};
  defs.forEach(def=>{
    const el = document.getElementById(`ctrl-${def.key}`);
    p[def.key] = el ? (def.type==='int' ? parseInt(el.value,10) : parseFloat(el.value)) : DEFAULTS[currentModel][def.key];
  });
  return p;
}
const btnReset = document.getElementById('btnReset');
if(btnReset){ btnReset.addEventListener('click', ()=>{ renderControls(currentModel); runAndDraw(); }); }

/* ===== Simulation ===== */
function simulate(model, p){
  const days = Math.max(1, Math.round(p.days||160));
  const dt = 1;
  const gamma = 1 / (p.inf_days||5);
  const beta  = p.beta||0.3;

  let S = p.N||1_000_000;
  let E = 0, I = 0, R = 0, D = 0, V = 0;
  if(model==='SEIR'){ E = p.E0||0; }
  if(model==='SIRV'){ V = p.V0||0; }
  I = p.I0||1;
  S = S - E - I - R - D - V;
  if(S<0){ S=0; }

  const sigma = model==='SEIR' ? 1 / (p.inc_days||3) : 0;
  const mu    = model==='SIRD' ? (p.mu||0) : 0;
  const nu    = model==='SIRV' ? (p.nu||0) : 0;

  const t=[]; const out={S:[], E:[], I:[], R:[], D:[], V:[]};

  for(let day=0; day<=days; day+=dt){
    t.push(day);
    out.S.push(S); out.E.push(E); out.I.push(I); out.R.push(R); out.D.push(D); out.V.push(V);

    const Ntot = Math.max(1, S+E+I+R+D+V);
    const infFlow = beta * S * I / Ntot;
    let dS=0,dE=0,dI=0,dR=0,dD=0,dV=0;

    if(model==='SIR'){
      dS = -infFlow;
      dI =  infFlow - gamma*I;
      dR =  gamma*I;
    }else if(model==='SEIR'){
      dS = -infFlow;
      dE =  infFlow - sigma*E;
      dI =  sigma*E - gamma*I;
      dR =  gamma*I;
    }else if(model==='SIS'){
      dS = -infFlow + gamma*I;
      dI =  infFlow - gamma*I;
    }else if(model==='SIRD'){
      dS = -infFlow;
      dI =  infFlow - gamma*I - mu*I;
      dR =  gamma*I;
      dD =  mu*I;
    }else if(model==='SIRV'){
      dS = -infFlow - nu*S;
      dI =  infFlow - gamma*I;
      dR =  gamma*I;
      dV =  nu*S;
    }

    S += dS*dt; E += dE*dt; I += dI*dt; R += dR*dt; D += dD*dt; V += dV*dt;

    if(S<0)S=0; if(E<0)E=0; if(I<0)I=0; if(R<0)R=0; if(D<0)D=0; if(V<0)V=0;
  }
  return {t, out};
}

/* ===== Chart (Canvas 2D) ===== */
const canvas = document.getElementById('chartCanvas');
const ctx = canvas.getContext('2d', {alpha:true});
function getCssVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
const COLORS = { S:getCssVar('--s'), E:getCssVar('--e'), I:getCssVar('--i'), R:getCssVar('--r'), D:getCssVar('--d'), V:getCssVar('--v') };
let lastCssW = 0, lastCssH = 0;
let dprBoost = 1;

/* Theme-aware colors for canvas UI */
const FG    = getCssVar('--fg')    || '#334155';
const MUTED = getCssVar('--muted') || '#64748b';
const PANEL = getCssVar('--panel') || '#ffffff';
const BRD   = getCssVar('--border')|| '#e5e7eb';

function resizeCanvas(){
  const parent = canvas.parentElement;
  const cssW = Math.max(1, parent.clientWidth);
  const cssH = Math.max(1, parent.clientHeight);
  if(cssW === lastCssW && cssH === lastCssH) return;
  lastCssW = cssW; lastCssH = cssH;

  const dpr = (window.devicePixelRatio || 1) * dprBoost;
  const newW = Math.floor(cssW * dpr);
  const newH = Math.floor(cssH * dpr);
  if(canvas.width !== newW) canvas.width = newW;
  if(canvas.height !== newH) canvas.height = newH;

  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr, dpr);
}
function crisp(n){ return Math.round(n) + 0.5; }
function drawAxes(xmin,xmax,ymin,ymax,w,h,m){
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = PANEL;
  ctx.fillRect(0,0,w,h);

  ctx.strokeStyle = BRD;
  ctx.lineWidth = 1;
  ctx.fillStyle = MUTED;
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';

  const ticks = 5;
  for(let i=0;i<=ticks;i++){
    const val = ymin + (i*(ymax-ymin))/ticks;
    const y = m.top + (1 - ( (val-ymin)/(ymax-ymin) )) * (h - m.top - m.bottom);
    const yy = crisp(y);
    ctx.beginPath(); ctx.moveTo(m.left, yy); ctx.lineTo(w - m.right, yy); ctx.stroke();
    const label = (val>=1000) ? (Math.round(val/1000)+'k') : (''+Math.round(val));
    ctx.fillText(label, 4, yy-2);
  }

  const xLabels = [xmin, xmin+(xmax-xmin)/4, xmin+(xmax-xmin)/2, xmin+3*(xmax-xmin)/4, xmax];
  xLabels.forEach((xv)=>{
    let x = m.left + ( (xv-xmin)/(xmax-xmin) ) * (w - m.left - m.right);
    x = Math.min(w - m.right - 12, Math.max(m.left + 2, x));
    ctx.fillText(''+Math.round(xv), x-6, h-6 - (m.bottom-24));
  });

  ctx.strokeStyle = BRD;
  const fw = (w - m.left - m.right);
  const fh = (h - m.top - m.bottom);
  ctx.strokeRect(crisp(m.left), crisp(m.top), Math.round(fw), Math.round(fh));
}
function plotLine(xs, ys, color, xmin, xmax, ymin, ymax, w, h, m){
  if(!ys || ys.length===0) return;
  ctx.beginPath();
  for(let i=0;i<ys.length;i++){
    const x = m.left + ( (xs[i]-xmin)/(xmax-xmin) ) * (w - m.left - m.right);
    const y = m.top  + (1 - ( (ys[i]-ymin)/(ymax-ymin) )) * (h - m.top - m.bottom);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.lineWidth = 2;
  ctx.strokeStyle = color;
  ctx.stroke();
}
const DE_LABEL = { S:'Anfällig', E:'Exponiert', I:'Infiziert', R:'Genesen', D:'Verstorben', V:'Geimpft' };
function seriesFor(model){
  return (model==='SEIR') ? ['S','E','I','R'] :
         (model==='SIRD') ? ['S','I','R','D'] :
         (model==='SIRV') ? ['S','I','R','V'] :
         (model==='SIS')  ? ['S','I'] :
                            ['S','I','R'];
}
function measureTextUnscaled(text){
  ctx.save(); ctx.setTransform(1,0,0,1,0,0);
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  const w = ctx.measureText(text).width; ctx.restore(); return w;
}
function drawLegend(seq, m, w, h){
  const r = 5, padX = 8, padY = 6, gapDotText = 6, gapItem = 16;
  let x = m.left + padX; let y = h - m.bottom + padY;
  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  ctx.textBaseline = 'top'; ctx.textAlign = 'left';
  seq.forEach((k)=>{
    const label = `${k} (${DE_LABEL[k]})`;
    const textW = measureTextUnscaled(label);
    const needW = 2*r + gapDotText + textW + gapItem;
    if(x + needW > w - m.right){ x = m.left + padX; y += 18; }
    ctx.beginPath(); ctx.arc(x + r, y + r, r, 0, Math.PI*2); ctx.fillStyle = COLORS[k]; ctx.fill();
    ctx.fillStyle = FG; ctx.fillText(label, x + 2*r + gapDotText, y);
    x += needW;
  });
}
function drawChart(data, model, N){
  const parent = canvas.parentElement;
  const w = parent.clientWidth;
  const h = parent.clientHeight;

  ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
  const seq = seriesFor(model);
  let estimateW = 0, lines = 1;
  seq.forEach(k=>{ estimateW += 10 + 6 + measureTextUnscaled(`${k} (${DE_LABEL[k]})`) + 16; });
  const available = w - 48 - 12 - 10;
  if(estimateW > available) lines = 2;
  const legendSpace = lines * 22;

  const m = {left:48, right:12, top:10, bottom:28 + legendSpace};

  const ymax = Math.max(N, ...['S','E','I','R','D','V'].map(k => Math.max(...data.out[k])));
  drawAxes(data.t[0], data.t[data.t.length-1], 0, ymax, w, h, m);
  seq.forEach(k => plotLine(data.t, data.out[k], COLORS[k], data.t[0], data.t[data.t.length-1], 0, ymax, w, h, m));
  drawLegend(seq, m, w, h);
}

/* ===== KPIs ===== */
function computeKPIs(model, p, data){
  const R0 = (p.beta||0)* (p.inf_days||5);
  const I = data.out.I;
  let peakI = 0, peakDay = 0;
  for(let i=0;i<I.length;i++){ if(I[i]>peakI){ peakI=I[i]; peakDay=i; } }
  const end = Object.fromEntries(['S','E','I','R','D','V'].map(k=>[k, Math.round(data.out[k][data.out[k].length-1]||0)]));
  return { R0, peakI, peakDay, end };
}
const kpiR0    = document.getElementById('kpiR0');
const kpiHerd  = document.getElementById('kpiHerd');
const kpiPeakI = document.getElementById('kpiPeakI');
const kpiPeakDay = document.getElementById('kpiPeakDay');
const kpiEnd   = document.getElementById('kpiEnd');
function updateKPIs(model, p, data){
  const k = computeKPIs(model, p, data);
  kpiR0 && (kpiR0.textContent = k.R0 ? k.R0.toFixed(2) : '–');
  kpiHerd && (kpiHerd.textContent = (k.R0>1) ? ` (Schwelle: ${(100*(1-1/k.R0)).toFixed(1)}%)` : ' (Schwelle: –)');
  kpiPeakI && (kpiPeakI.textContent = `${numfmt(Math.round(k.peakI))} (${(100*k.peakI/(p.N||1)).toFixed(2)}%)`);
  kpiPeakDay && (kpiPeakDay.textContent = ''+k.peakDay);
  if(kpiEnd){
    const parts = [];
    if(model==='SEIR'){ parts.push(`E=${numfmt(k.end.E)}`); }
    parts.push(`S=${numfmt(k.end.S)}`, `I=${numfmt(k.end.I)}`, `R=${numfmt(k.end.R)}`);
    if(model==='SIRD'){ parts.push(`D=${numfmt(k.end.D)}`); }
    if(model==='SIRV'){ parts.push(`V=${numfmt(k.end.V)}`); }
    kpiEnd.textContent = parts.join(' · ');
  }
  return k;
}

/* ===== PNG Export (Classic Wasserzeichen) ===== */
const WATERMARK = [
  { text: 'Rausch (2025) • classic.infektionsdynamiken.de', font: '600 13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial' },
  { text: 'Kompartimentmodell-Simulation – Classic Edition • Infektionsdynamiken verstehen', font: '13px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial' }
];
const btnPNG = document.getElementById('btnPNG');
if(btnPNG){
  btnPNG.addEventListener('click', ()=>{
    const dpr = (window.devicePixelRatio || 1);
    const cssW = canvas.parentElement.clientWidth;
    const cssH = canvas.parentElement.clientHeight;
    const off = document.createElement('canvas');
    off.width  = Math.floor(cssW * dpr);
    off.height = Math.floor(cssH * dpr);
    const octx = off.getContext('2d');
    octx.scale(dpr, dpr);
    octx.drawImage(canvas, 0, 0, off.width, off.height, 0, 0, cssW, cssH);
    const pad = 10; let y = pad + 2;
    octx.textAlign = 'right'; octx.textBaseline = 'top'; octx.fillStyle = 'rgba(15,23,42,0.76)';
    WATERMARK.forEach((ln)=>{
      octx.font = ln.font; octx.fillText(ln.text, cssW - pad, y);
      const m = octx.measureText(ln.text);
      const lineH = Math.max(16, m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + 2);
      y += lineH;
    });
    const a = document.createElement('a');
    const ts = new Date(); const pad2 = n => String(n).padStart(2,'0');
    const fname = `Kompartiment-Simulator_${currentModel}_${ts.getFullYear()}${pad2(ts.getMonth()+1)}${pad2(ts.getDate())}_${pad2(ts.getHours())}${pad2(ts.getMinutes())}.png`;
    a.download = fname; a.href = off.toDataURL('image/png'); a.click();
  });
}

/* ===== PDF / Print ===== */
function buildParamsTable(model, p){
  const defs = CONTROLS[model];
  return defs.map(def=>{
    const val = p[def.key];
    const formatted = (def.type==='int') ? numfmt(val) : (''+val);
    return `<tr><th>${def.label}</th><td>${formatted}</td></tr>`;
  }).join('');
}
function buildKpisTable(model, p, k){
  const lines = [
    ['R₀', k.R0 ? k.R0.toFixed(2) : '–'],
    ['Herdenschwelle', (k.R0>1) ? `${(100*(1-1/k.R0)).toFixed(1)}%` : '–'],
    ['Peak I', `${numfmt(Math.round(k.peakI))} (${(100*k.peakI/(p.N||1)).toFixed(2)}%) am Tag ${k.peakDay}`]
  ];
  const endParts = [];
  if(model==='SEIR') endParts.push(`E=${numfmt(k.end.E)}`);
  endParts.push(`S=${numfmt(k.end.S)}`, `I=${numfmt(k.end.I)}`, `R=${numfmt(k.end.R)}`);
  if(model==='SIRD') endParts.push(`D=${numfmt(k.end.D)}`);
  if(model==='SIRV') endParts.push(`V=${numfmt(k.end.V)}`);
  lines.push(['Endstände', endParts.join(' · ')]);
  return lines.map(([a,b])=>`<tr><th>${a}</th><td>${b}</td></tr>`).join('');
}
function preparePrint(){
  // timestamp
  const tsEl = document.getElementById('printTs');
  if(tsEl){
    const d = new Date();
    const pad = n=>String(n).padStart(2,'0');
    tsEl.textContent = `${pad(d.getDate())}.${pad(d.getMonth()+1)}.${d.getFullYear()} · ${pad(d.getHours())}:${pad(d.getMinutes())}`;
  }
  renderModelInfo(currentModel);
  const p = readParams();
  const data = simulate(currentModel, p);
  const k = computeKPIs(currentModel, p, data);
  const pt = document.getElementById('paramsTable');
  const kt = document.getElementById('kpisTable');
  if(pt) pt.innerHTML = buildParamsTable(currentModel, p);
  if(kt) kt.innerHTML = buildKpisTable(currentModel, p, k);

  dprBoost = 2.5; lastCssW = 0; lastCssH = 0; resizeCanvas(); drawChart(data, currentModel, p.N||1);
}
function cleanupPrint(){ dprBoost = 1; lastCssW = 0; lastCssH = 0; resizeCanvas(); runAndDraw(); }
const btnPDF = document.getElementById('btnPDF');
if(btnPDF){ btnPDF.addEventListener('click', ()=>{ preparePrint(); setTimeout(()=>window.print(), 50); }); }
if('onbeforeprint' in window){ window.addEventListener('beforeprint', preparePrint); window.addEventListener('afterprint', cleanupPrint); }

/* ===== Run-all ===== */
function runAndDraw(){ const p = readParams(); const data = simulate(currentModel, p); drawChart(data, currentModel, p.N||1); updateKPIs(currentModel, p, data); }
function init(){ resizeCanvas(); renderControls(currentModel); renderModelInfo(currentModel); runAndDraw(); }
let rafToken = null;
function scheduleRedraw(){ if(rafToken) return; rafToken = requestAnimationFrame(()=>{ rafToken=null; resizeCanvas(); runAndDraw(); }); }
window.addEventListener('load', scheduleRedraw);
window.addEventListener('resize', scheduleRedraw);
try{ const ro = new ResizeObserver(scheduleRedraw); ro.observe(document.querySelector('.chartPh')); }catch(e){}
init();
</script>
</body>
</html>
